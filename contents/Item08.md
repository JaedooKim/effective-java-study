Java 에서는 2가지의 객체 소멸자를 제공한다.
- finalizer
- cleaner

이 2가지 객체 소멸자는 JVM내의 GC가 작동할 때 실행되는 구문이다.
기본적으로 이 2가지 구문은 사용하지 말아야 한다.
현재 Java 9 버전 부터는 Object 클래스에 대한 finalizer를 Deprecated 처리하였다. 

**finalizer와 cleaner를 사용하지 말아야 하는 이유**
1. 실행을 보장할 수 없다
2. 느리다.
3. 시스템 전체 장애를 유발 할 수 있다.
4. finalizer 공격에 취약하다

**그럼 Finalizer나 cleaner는 어디에 쓰나?**
적절한 쓰임새는 두 가지 정도 있다. 하나는 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할이다. cleaner나 finalizer가 즉시 호출되리라는 보장은 없지만, 클라이언트가 하지 않은 자원 회수를 늦게라도 해주는 것이 아예 안하는 것보다 낫다. 이런 안전망 역할의 finalizer를 작성할 때는 그럴만한 값어치가 있는지 심사숙고하자. 자바 라이브러리 중 FileInputStream, FileOutputStream, ThreadPoolExecutor가 대표적이다.

두 번째 예로 네이티브 피어와 연결된 객체에서다. 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다. 네이티브 피어는 자바 객체가 아니기 때문에 가비지 컬렉터는 그 존재를 알지 못한다. 그 결과 자바 피어를 회수할 때 네이티브 객체까지 회수하지 못한다. cleaner나 finalizer가 나서서 처리하기에 적당한 작업이다. 단, 성능 저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때에만 해당 된다. 성능 저하를 감당할 수 없거나 네이티브 피어가 사용하는 자원을 즉시 회수해야 한다면 앞서 설명한 close 메서드를 사용해야 한다.


**finalizer 기능이 필요한 경우에는 어떻게?**
Autocloseable Interface를 사용하여 close를 호출시키도록 하자.
다음장의 try-catch-resource 구문에서 설명하도록 하겠다.
cleaner(자바 8까지는 finalizer)는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 물론 이런 경우라도 불확실성과 성능 저하에 주의해야 한다.